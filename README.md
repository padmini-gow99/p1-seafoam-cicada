Ticket Triage Mini Project (Planning + Implementation Notes)

This document captures both the planning process I followed before writing any code, and the final structure of the small LangGraph-based triage agent.
The goal was to understand the problem clearly, outline the architecture, identify the utilities I would need, and then implement a minimal but working system.

1. Initial Planning (Written Before Coding)

This section is intentionally written as a personal engineering plan.

What the assignment requires

Build a small LangGraph workflow that processes customer-support tickets

Extract or identify an order ID

Classify the issue type

Optionally fetch order details using a “tool”

Generate a customer-facing reply + internal recommendation

Expose everything through a FastAPI endpoint

Provide tests

Provide a README and example cURL request

Key entities in the workflow

Customer → sends the message

Assistant Agent → performs classification + reasoning

Admin (implicit) → approves/rejects through recommendations

Required Explanation: Customer → Assistant → Admin Roles

In this mini-project, the admin is not implemented as a separate agent.
Instead, admin decisions are expressed through the recommendation field generated by the assistant.
This field indicates what an admin would logically decide next—
such as approving an action, rejecting it, or requesting manual review.

This keeps the architecture simple while still matching the expected
customer → assistant → admin interaction flow described in the assignment.

Core Concepts I Need

LangGraph StateGraph

TypedDict State to store:

messages

ticket_text

query

order_id

issue_type

evidence

reply

recommendation

tool_result

Nodes with deterministic responsibilities

ingest

classify_issue

fetch_order

draft_reply

Utilities

ChatOpenAI (LLM)

StateGraph

SQLite + ORM layer

FastAPI

pytest

dotenv

Graph Architecture (Before Writing Code)

Planned sequence:

(1) ingest
    ↓
(2) classify_issue
    ↓          ↘
    if call_tool=false → skip fetch_order
    ↓
(3) fetch_order (Tool Node)
    ↓
(4) draft_reply
    ↓
   END

Behavior Notes

ingest → builds clean message history

classify_issue → extracts order ID, identifies issue, decides on tool usage

fetch_order → runs only if needed

draft_reply → generates final JSON output

Final output includes:

reply

issue_type

order_id

evidence

recommendation

This planning step ensured that each node had a single responsibility.

2. Final Project Overview

After implementing based on the plan above, the project now works as a self-contained triage workflow with all requirements completed.

3. Project Structure
p1-seafoam-cicada/
│
├── app/
│   ├── triage_agent.py      # LangGraph workflow + FastAPI app
│   ├── database.py          # SQLite model + helper function (get_order_by_id)
│   ├── seed_data.py         # Creates and seeds the orders.db file
│   └── tests/
│       └── test_triage_agent.py
│
├── orders.db                # SQLite DB (auto-generated)
├── .env                     # API keys + tracing flags
├── requirements.txt
└── README.md

4. How to Run the Project
1. Create & activate virtual environment
python -m venv .venv
.\.venv\Scripts\activate

2. Install dependencies
pip install -r requirements.txt

3. Create .env file
OPENAI_API_KEY=your_api_key_here
LANGCHAIN_TRACING_V2=true
LANGCHAIN_PROJECT=viridien-triage

4. Seed database
python -m app.seed_data

5. Run API
uvicorn app.triage_agent:app --reload

6. Visit API Docs
http://127.0.0.1:8000/docs

5. Example Request

POST → /triage/invoke

{
  "ticket_text": "Please update my order status for ORD1003",
  "query": "mark this as delivered",
  "order_id": "ORD1003"
}

Example Response
{
  "reply": "Your order ORD1003 has been updated successfully.",
  "issue_type": "update_status",
  "order_id": "ORD1003",
  "evidence": "Customer explicitly asked to update status.",
  "recommendation": "No manual review required."
}

6. Final LangGraph Workflow Diagram
            ┌──────────────┐
            │    ingest     │
            └───────┬──────┘
                    │
            ┌───────▼────────┐
            │ classify_issue  │
            └───────┬────────┘
        call_tool?  │
           yes       │ no
            │        │
     ┌──────▼───┐    │
     │fetch_order│    │
     └──────┬────┘    │
            │          │
            └────┬─────┘
                 ▼
         ┌─────────────┐
         │ draft_reply │
         └───────┬─────┘
                 ▼
                END

7. Notes on Personal Development Process

Writing the planning notes first helped me:

keep the state consistent

enforce node responsibilities

follow assignment requirements clearly

maintain a deterministic graph flow

Cursor was used only for code navigation and refactoring.
All architectural planning was done manually before coding.

8. Possible Future Enhancements

Add real tool actions (cancel order, refund, update status)

Add multi-agent loop with admin approval

Add RAG knowledge base for policy answers

Add authentication + dashboard

Expand test coverage
